/**
 * <DynamicOptionList />
 */
import React, { useCallback, useEffect, useRef, useState } from 'react'

import PropTypes from 'prop-types'

import ID from '../../../utils/uuid'

const DynamicOptionList = ({
  element: propsElement,
  data = {},
  updateElement = () => {},
  preview = null,
  canHaveOptionValue = false,
  canHaveOptionCorrect = false,
  canHaveInfo = false,
}) => {
  const [element, setElement] = useState(propsElement)
  const [dirty, setDirty] = useState(false)
  const previousTimeRef = useRef(0)
  const timeoutIdRef = useRef(null)

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (timeoutIdRef.current) {
        clearTimeout(timeoutIdRef.current)
      }
    }
  }, [])

  const setValue = (text) => text.replace(/[^A-Z0-9]+/gi, '_').toLowerCase()

  const syncOptionsWithSameColumnElements = useCallback(
    (options) => {
      if (!preview || !propsElement.parentId) {
        return
      }

      let parentElement
      const getDataById =
        preview.getDataById ||
        (preview.state?.data && ((id) => preview.state.data.find((x) => x.id === id)))

      const { col: columnIndex, row: currentRowIndex } = propsElement
      if (columnIndex === undefined || currentRowIndex === undefined) {
        return
      }

      if (typeof getDataById === 'function') {
        parentElement = getDataById(propsElement.parentId)
      }

      if (
        !parentElement ||
        !parentElement.childItems ||
        parentElement.element !== 'DynamicColumnRow' ||
        parentElement.columns?.[columnIndex].isSync === false
      ) {
        return
      }

      const updateElementFunc =
        typeof preview.updateElement === 'function' ? preview.updateElement : updateElement

      if (!updateElementFunc) {
        return
      }

      parentElement.childItems.forEach((row, rowIndex) => {
        if (rowIndex === currentRowIndex) return

        const elementId = row[columnIndex]
        if (!elementId) return

        const elementData = getDataById(elementId)

        if (
          !elementData ||
          elementData.element !== propsElement.element ||
          !Array.isArray(elementData.options)
        ) {
          return
        }

        const newOptions = options.map((option, i) => {
          if (i >= elementData.options.length) {
            return {
              ...option,
              key: ID.uuid(),
            }
          }

          const { key } = elementData.options[i]
          return {
            ...option,
            key: key || ID.uuid(),
            info: option.info ?? false,
            correct: option.correct ?? false,
          }
        })

        const updatedElement = {
          ...elementData,
          options: newOptions,
          dirty: true,
        }

        updateElementFunc(updatedElement)
      })
    },
    [preview, propsElement, updateElement]
  )

  // Throttle utility function
  const throttle = useCallback((func, wait) => {
    return (...args) => {
      const now = Date.now()
      const remaining = wait - (now - previousTimeRef.current)

      if (remaining <= 0 || remaining > wait) {
        if (timeoutIdRef.current) {
          clearTimeout(timeoutIdRef.current)
        }
        previousTimeRef.current = now
        func(...args)
      } else if (!timeoutIdRef.current) {
        timeoutIdRef.current = setTimeout(() => {
          previousTimeRef.current = now
          timeoutIdRef.current = null
          func(...args)
        }, remaining)
      }
    }
  }, [])

  const handleOptionChangeThrottled = useCallback(
    throttle((optionIndex, { target: { value } }) => {
      setElement((prevElement) => {
        const newElement = { ...prevElement }
        const currentOption = newElement.options[optionIndex]
        const autoGeneratedValue = setValue(currentOption.text)
        const shouldAutoGenerate =
          !currentOption.value || currentOption.value === autoGeneratedValue

        const val = shouldAutoGenerate ? setValue(value) : currentOption.value

        newElement.options[optionIndex].text = value
        newElement.options[optionIndex].value = val

        setDirty(true)
        setTimeout(() => syncOptionsWithSameColumnElements(newElement.options), 0)
        return newElement
      })
    }, 200),
    [throttle, syncOptionsWithSameColumnElements]
  )

  const handleValueChangeThrottled = useCallback(
    throttle((optionIndex, { target: { value } }) => {
      setElement((prevElement) => {
        const newElement = { ...prevElement }
        newElement.options[optionIndex].value = value

        setDirty(true)
        setTimeout(() => syncOptionsWithSameColumnElements(newElement.options), 0)
        return newElement
      })
    }, 200),
    [throttle, syncOptionsWithSameColumnElements]
  )

  const handleOptionCorrect = useCallback(
    (optionIndex) => {
      setElement((prevElement) => {
        const newElement = { ...prevElement }
        const option = newElement.options[optionIndex]

        if (Object.prototype.hasOwnProperty.call(option, 'correct')) {
          delete option.correct
        } else {
          option.correct = true
        }

        setTimeout(() => {
          updateElement.call(preview, newElement)
          syncOptionsWithSameColumnElements(newElement.options)
        }, 0)

        return newElement
      })
    },
    [preview, updateElement, syncOptionsWithSameColumnElements]
  )

  const handleOptionInfo = useCallback(
    (optionIndex) => {
      setElement((prevElement) => {
        const newElement = { ...prevElement }
        const option = newElement.options[optionIndex]

        if (Object.prototype.hasOwnProperty.call(option, 'info')) {
          delete option.info
        } else {
          option.info = true
        }

        setTimeout(() => {
          updateElement.call(preview, newElement)
          syncOptionsWithSameColumnElements(newElement.options)
        }, 0)

        return newElement
      })
    },
    [preview, updateElement, syncOptionsWithSameColumnElements]
  )

  const updateOption = useCallback(() => {
    if (dirty) {
      updateElement.call(preview, element)
      setDirty(false)
      setTimeout(() => syncOptionsWithSameColumnElements(element.options), 0)
    }
  }, [dirty, element, preview, updateElement, syncOptionsWithSameColumnElements])

  const addOption = useCallback(
    (index) => {
      setElement((prevElement) => {
        const newElement = { ...prevElement }
        const nextValue =
          Math.max(
            ...newElement.options.map(({ value }) =>
              Number.isNaN(Number(value)) ? 0 : parseInt(value, 10)
            )
          ) + 1

        newElement.options.splice(index + 1, 0, {
          value: nextValue,
          text: '',
          key: ID.uuid(),
        })

        setDirty(true)
        setTimeout(() => syncOptionsWithSameColumnElements(newElement.options), 0)
        return newElement
      })
    },
    [syncOptionsWithSameColumnElements]
  )

  const removeOption = useCallback(
    (index) => {
      setElement((prevElement) => {
        const newElement = { ...prevElement }
        newElement.options.splice(index, 1)

        setDirty(true)
        setTimeout(() => syncOptionsWithSameColumnElements(newElement.options), 0)
        return newElement
      })
    },
    [syncOptionsWithSameColumnElements]
  )

  const isInDynamicColumn = !!(
    propsElement?.parentId &&
    propsElement?.col !== undefined &&
    propsElement?.row !== undefined
  )

  const shouldShowInfo =
    canHaveInfo || (isInDynamicColumn && propsElement?.element === 'Checkboxes')

  const shouldShowCorrect =
    canHaveOptionCorrect || (isInDynamicColumn && propsElement?.element === 'Checkboxes')

  return (
    <div className="dynamic-option-list">
      <ul>
        <li>
          <div className="row">
            <div className="col-sm-5">
              <b>Options</b>
            </div>
            {canHaveOptionValue && (
              <div className="col-sm-2">
                <b>Value</b>
              </div>
            )}
            {shouldShowInfo && (
              <div className="col-sm-1">
                <b>Info</b>
              </div>
            )}
            {shouldShowCorrect && (
              <div className="col-sm-1">
                <b>Correct</b>
              </div>
            )}
          </div>
        </li>
        {element.options.map((option, index) => {
          const itemKey = `edit_${option.key}`
          const val = option.value || ''
          return (
            <li className="clearfix" key={itemKey}>
              <div className="row">
                <div className="col-sm-5">
                  <input
                    type="text"
                    className="form-control"
                    style={{ width: '100%' }}
                    value={option.text}
                    onChange={(e) => {
                      const newElement = { ...element }
                      newElement.options[index].text = e.target.value
                      setElement(newElement)
                      setDirty(true)
                      handleOptionChangeThrottled(index, e)
                    }}
                    onBlur={updateOption}
                  />
                </div>
                {canHaveOptionValue && (
                  <div className="col-sm-2">
                    <input
                      type="text"
                      className="form-control"
                      style={{ width: '100%' }}
                      value={val}
                      onChange={(e) => handleValueChangeThrottled(index, e)}
                      onBlur={updateOption}
                    />
                  </div>
                )}

                {canHaveOptionValue && canHaveInfo && (
                  <div className="col-sm-1">
                    <input
                      className="form-control"
                      type="checkbox"
                      value="1"
                      checked={Object.prototype.hasOwnProperty.call(option, 'info') && option.info}
                      onChange={() => handleOptionInfo(index)}
                    />
                  </div>
                )}
                {canHaveOptionValue && canHaveOptionCorrect && (
                  <div className="col-sm-1">
                    <input
                      className="form-control"
                      type="checkbox"
                      value="1"
                      checked={
                        Object.prototype.hasOwnProperty.call(option, 'correct') && option.correct
                      }
                      onChange={() => handleOptionCorrect(index)}
                    />
                  </div>
                )}

                <div className="col-sm-3">
                  <div className="dynamic-options-actions-buttons">
                    <button
                      onClick={() => addOption(index)}
                      type="button"
                      className="btn btn-success"
                    >
                      <i className="fas fa-plus-circle" />
                    </button>
                    {index > 0 && (
                      <button
                        onClick={() => removeOption(index)}
                        type="button"
                        className="btn btn-danger"
                      >
                        <i className="fas fa-minus-circle" />
                      </button>
                    )}
                  </div>
                </div>
              </div>
            </li>
          )
        })}
      </ul>
      {dirty && (element.dirty = true)}
    </div>
  )
}

DynamicOptionList.propTypes = {
  element: PropTypes.shape({
    options: PropTypes.arrayOf(
      PropTypes.shape({
        text: PropTypes.string,
        value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
        key: PropTypes.string,
      })
    ).isRequired,
    parentId: PropTypes.string,
    col: PropTypes.number,
    row: PropTypes.number,
    element: PropTypes.string,
  }).isRequired,
  data: PropTypes.shape({}),
  updateElement: PropTypes.func,
  preview: PropTypes.shape({
    state: PropTypes.shape({
      data: PropTypes.arrayOf(
        PropTypes.shape({
          id: PropTypes.string.isRequired,
        })
      ),
    }),
    getDataById: PropTypes.func,
    updateElement: PropTypes.func,
  }),
  canHaveOptionValue: PropTypes.bool,
  canHaveOptionCorrect: PropTypes.bool,
  canHaveInfo: PropTypes.bool,
}

export default DynamicOptionList
